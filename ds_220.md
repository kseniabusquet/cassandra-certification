- [DS220: Data Modelling with Apache Cassandra](#ds220-data-modelling-with-apache-cassandra)
  - [Data Modelling Overview](#data-modelling-overview)
  - [Relational vs. Apache Cassandra](#relational-vs-apache-cassandra)
    - [Relational Data Modelling Methodology](#relational-data-modelling-methodology)
    - [Cassandra Data Modelling Methodology](#cassandra-data-modelling-methodology)
    - [Transactions and ACID Compliance](#transactions-and-acid-compliance)
    - [Apache Cassandra and CAP Theorem](#apache-cassandra-and-cap-theorem)
    - [Apache Cassandra and Denormalization](#apache-cassandra-and-denormalization)
      - [Relational Joins](#relational-joins)
      - [Referential Integrity - Relational](#referential-integrity---relational)
  - [Working with KillrVideo](#working-with-killrvideo)
    - [Problems KillrVideo Faces](#problems-killrvideo-faces)
    - [Solutions attempted - Relational](#solutions-attempted---relational)
  - [Apache Cassandra Terminology](#apache-cassandra-terminology)
    - [Basic terms and definitions](#basic-terms-and-definitions)
    - [Text Data Types](#text-data-types)
    - [Integer Data Types](#integer-data-types)
    - [Time, timestamp and unique identifiers](#time-timestamp-and-unique-identifiers)
    - [Specialty Types](#specialty-types)
  - [Partitioning and Storage Structure](#partitioning-and-storage-structure)
  - [Clustering Columns](#clustering-columns)
    - [WITH CLUSTERING ORDER BY](#with-clustering-order-by)
    - [Querying Clustering Columns](#querying-clustering-columns)
  - [Denormalization](#denormalization)
  - [Collection Columns](#collection-columns)
    - [SET Collection Type](#set-collection-type)
    - [LIST Collection Type](#list-collection-type)
    - [MAP Collection Type](#map-collection-type)
    - [FROZEN](#frozen)
  - [UDT - User Defined Type](#udt---user-defined-type)
  - [Counters](#counters)
    - [Counter Considerations](#counter-considerations)
  - [User Defined Functions (UDFs) and User Defined Aggregates (UDAs)](#user-defined-functions-udfs-and-user-defined-aggregates-udas)
    - [UDFs](#udfs)
    - [UDAs](#udas)
    - [Querying with a UDF and a UDA](#querying-with-a-udf-and-a-uda)


### DS220: Data Modelling with Apache Cassandra

#### Data Modelling Overview

- Analyze requirements of the domain
- Identify entities and relationships - **Conceptual Data Model**
- Identify queries - **Workflow and Access Patterns**
- Specify the schema - **Logical Data Model**
- Get something working with CQL - **Physical Data Model**
- Optimize and tune

![Data Modelling Process](img/data_modelling_process.png)

*Data Modelling is a science:*

- Apply tested methodologies
- Make improvements
- Reproducible

*Data Modelling is also an art:*

- Think outside of the box
- Non-standard solution - requires creativity
- Be careful - different data models have different costs

> Main principle: design tables that support the queries.

#### Relational vs. Apache Cassandra

![Relational vs. Cassandra](img/relational_vs_cassandra.png)

##### Relational Data Modelling Methodology

(one of many)

![Relational Data Modelling Methodology](img/relational_methodology.png)

##### Cassandra Data Modelling Methodology

![Cassandra Methodology](img/cassandra_methodology.png)

> We consider Application Workflow earlier in the process and incorporating that analysis into the Logical Data Modelling Phase rather than waiting until we're optimizing a Physical Relational Model.

![Relational vs Cassandra](img/relational_vs_cassandra_1.png)

##### Transactions and ACID Compliance

*Relational DB are ACID compliant*

![ACID](img/acid.png)

**Cassandra doesn't support ACID semantics.**

- ACID causes a significant performance penalty
- Not required for many use cases
- However, a single Cassandra write operation demonstrates ACID properties
  - INSERTs, UPDATEs and DELETEs are atomic, isolated and durable
  - Tunable consistency for data replicated to nodes, but does not handle application integrity constraints

##### Apache Cassandra and CAP Theorem

![CAP Theorem](img/cap_theorem_2.png)

- by default, Cassandra is an AP database
- However, this is tunable with CL
- By tuning CL, you can make more CP than AP
- However! Cassandra isn't designed to be CA because you can't sacrifice partition tolerance

This is often referred as **tunable consistency**

##### Apache Cassandra and Denormalization

###### Relational Joins

> Joining users to comments table

![Relational Joins](img/relational_joins.png)

A join performs well when all of the relevant data is available on a single node. The main problem with joins in the distributed system is that the referenced data would most often exist on another node, which can have an unpredictable impact on the latency as the database scale increases.

![Denormalization](img/denormalization.png)

###### Referential Integrity - Relational

Joins rely on referential integrity constraints to combine data

- a value in one table requires the same value to exist in another table
- if there is a user in table `users_by_email` then the user must also exist in table `users`

![Referential Integrity](img/referential_integrity.png)

**Referential Integrity is not guaranteed by Cassandra, instead, we have to enforce it on the application level.**

- Due to performance reasons - would require a read before a write
- Not an issue that has to be fixed on the Apache Cassandra side
- Referential integrity can be enforced in an application design - more work for developers

OR

- Run DSE Analytics with Apache Spark to validate that duplicate data is consistent

#### Working with KillrVideo

![KillrVideo](img/killrvideo.png)

##### Problems KillrVideo Faces

- **Scalability** - Must be able to support constant addition of new users and videos
- **Reliability** - Must always be available
- **Ease of use** - Must be easy to manage and maintain

##### Solutions attempted - Relational

- single points of failure (when the DB crashes)
- scaling complexity
- reliability issues
- difficult to serve users worldwide (lag)

#### Apache Cassandra Terminology

##### Basic terms and definitions

**Data Model**
- an abstract model for organizing elements of data
- based on the queries you want to perform

**Keyspace**
- similar to relational schema - outermost grouping of data
- all tables live inside a keyspace
- keyspace is the container for replication

**Table**
- grouped into keyspaces
- contain columns

**Partition**
- rows of data that are stored on a particular node in your based on a partitioning strategy

More specific to the tables themselves

**Row**
- one or more CQL rows stored together on a partition

**Column**
- similar to a column in a relational database
- **primary key**: used to access the data in a table and guarantees uniqueness

**Partition key**
- defines the node on which the data is stored

**Clustering Column**
- defines the roder of rows **within** a partition

##### Text Data Types

- **Ascii**: US-ASCII characters
- **Text**: UTF-8 encoded string
- **Varchar**: UTF-8 encoded string

##### Integer Data Types

- **Tinyint**: 8-bit signed integer
- **Smallint**: 16-bit signed integer
- **Int**: 32-bit signed integer
- **Bigint**: 64-bit signed integer
- **Varint**: Arbitrary-precision integer - F-8 encoded string
- **Decimal**: Variable-precision decimal, supports integers and floats
- **Float**: 32-bit IEEE-754 floating point
- **Double**: 64-bit IEEE-754 floating point

##### Time, timestamp and unique identifiers

- **Date**: 32-bit unsigned integer - number of days since epoch (Jan 1, 1970)
- **Duration**: Signed 64-bit integer - amount of time in nanoseconds
- **Time**: Encoded 64-bit signed - number of nanoseconds since midnight
- **Timestamp**: 64-bit signed inteer - date and time since epoch in milliseconds
- **UUID**: 128-bit universally unique identifier - generate with the UUID function
- **TimeUUID**: unique identifier that includes a "conflict-free" timesdtamp - generate with the NOW function

##### Specialty Types

- **Blob**: Arbitrary bytes (no validation), expressed as hexadecimal
- **Boolean**: Stored internally as true or false
- **Counter**: 64-bit signed integer - only one counter column is allowed per table
- **Inet**: IP address string in IPv4 or IPv6 format

#### Partitioning and Storage Structure

![Storage Structure](img/storage_structure.png)

CQL's PARTITION KEY clause determines partitioning criteria in the primary key

**WHERE on non-primary key columns**

- Cassandra distributes partitions across nodes
- WHERE on any field other than partition key would require a scan of all partitions on all nodes
- Inefficient access pattern

![Nodes](img/nodes.png)

**WHERE on partition key values**
- We can WHERE on a partition key value as well as clustering columns
- Cassandra uses a hashing algorithm to quicly determine which node(s) contain the desired partition

![Nodes 2](img/nodes_2.png)

**Primary Key**

Simple Primary Key

- contains only the partition key
- determines which node stores the data
-
![Simple primary key](img/simple_primary_key.png)

**Composite Partition Keys**

Multi-value primary key

![Composite Partition Key](img/composite_partition_key.png)

**Primary Key vs. Partition Key**

- **Partition key**: the part of the primary key that determines what node the partition is stored on; where in the cluster is my data
- **Primary key**: includes partition key and any/all clustering columns; uniqueness
- Can they be the same? Yes! But not usually.

#### Clustering Columns

- come after partition key within PRIMARY KEY clause
- data displays the same as before

![Clustering Columns](img/clustering_columns.png)

Clustering sorts CQL rows in partitions

![Clustering Columns 2](img/clustering_columns_2.png)

![With vs. without clustering column](img/clustering_columns_3.png)

Clustering column values stored sorted

![Sorted Clustering Columns](img/sorted_clustering_columns.png)

##### WITH CLUSTERING ORDER BY

```sql
CREATE TABLE videos (
  id int,
  name text,
  runtime int,
  year int,
  PRIMARY KEY ((year), name)
) WITH CLUSTERING ORDER BY (name DESC);
```

##### Querying Clustering Columns

> You can query on clustering coumns because lookup is fast

```sql
SELECT * FROM videos WHERE year = 2014 AND name = 'Mockingjay';
```

![Query 1](img/query_1.png)

**Range**

```sql
SELECT * FROM videos WHERE year = 2014 AND name >= 'Interstellar';
```

![Query 2](img/query_2.png)

#### Denormalization

**Typical Relational Structure**

![Relational Structure](img/relational_structure.png)

```sql
SELECT comment FROM videos JOIN comments ON videos.id = comments.video_id WHERE title = 'Interstellar';
```

![Relational Example](img/relational_example.png)

![Results of the query](img/relational_query.png)

**Denormalizing for Quewry Performance**

![Denormalization](img/denormalization_1.png)

```sql
CREATE TABLE comments_by_video (
  video_title text,
  comment_id timeuuid,
  user_id text,
  video_id timeuuid,
  comment text,
  PRIMARY KEY ((video_title), comment_id)
);

CREATE TABLE comments_by_user (
  user_login text,
  comment_id timeuuid,
  user_id text,
  video_id timeuuid,
  comment text,
  PRIMARY KEY ((user_login), comment_id)
);
```

#### Collection Columns

Group and store data together in a column

- collection columns are multi-valued columns
- designed to store a small amount of data
- retrieved in its entirety
- cannot nest a collection inside another collection - unless you use FROZEN

##### SET Collection Type

- typed collection of unique values
- stored unordered, but retrieved in sorted order

```sql
CREATE TABLE users (
  id text PRIMARY KEY,
  fname text,
  lname text,
  emails set<text>
);

INSERT into users (id, fname, lname, emails)
VALUES ('cass123', 'Cassandra', 'Dev', {'cass@dev.com', 'cassd@gmail.net'});
```

##### LIST Collection Type

- like SET - collection of values in same cell
- do not need to be unique and can be duplicated
- stored in a particular order

```sql
ALTER TABLE users ADD freq_dest list<text>;

UPDATE users SET freq_dest = ['Berlin', 'London', 'Paris'] WHERE id = 'cass123';
```

##### MAP Collection Type

- typed collection of key-value pairs - name and pair of typed values
- ordered by unique keys

```sql
ALTER TABLE users ADD todo map<timestamp , text>;

UPDATE users SET todo = {'2018-1-1' : 'create database', '2018-1-2' : 'load data and test', '2018-2-1' : 'move to production'} WHERE id = 'cass123';
```

##### FROZEN

- if you want to nest datatypes, you have to use FROZEN
- using FROZEN in a collection will serialize multiple components into a single value
- values in a FROZEN collection are treated like blobs
- non-frozen types allow updates to individual fields

#### UDT - User Defined Type

Attach multiple data fields to a column

- UDTs group related fields of information
- UDTs can attach multiple data fields, each named and typed, to a single column
- can be any datatype including collections and other UDTs
- allows embedding more complex data within a single column

> Creating the Types

```sql
CREATE TYPE address (
  street text,
  city text,
  zip_code int,
  phones set<text>
);

CREATE TYPE full_name (
  first_name text,
  last_name text
);
```

> Using the newly created types in a table definition

```sql
CREATE TABLE users (
  id uuid,
  name frozen <full_name>,
  direct_reports set<frozen <full_name>>,
  addresses map<text, frozen <address>>,
  PRIMARY KEY ((id))
);
```

#### Counters

- column used to store a 64-bit signed integer
- changed incrementally - incremented or decremented
- values are changed using UPDATE
- need specially dedicated tables - can only have primary key and counter columns
  - can have more than one counter column

```sql
CREATE TABLE moo_counts (
  cow_name text,
  moo_count counter,
  PRIMARY KEY ((cow_name))
);

UPDATE moo_counts SET moo_count = moo_count + 8 WHERE cow_name = 'Betsy';
```

##### Counter Considerations

> Some things to be aware of

- distributed system can cause consistency issues with counters in some cases
- cannot INSERT or assign values - default value is "0"
- must be only non-primary key column(s)
- not idempotent
- must use UPDATE command - DataStax Enterprise rejects USING TIMESTAMP or USING TTL to update counter columns
- counter columns cannot be indexed or deleted

#### User Defined Functions (UDFs) and User Defined Aggregates (UDAs)

##### UDFs

- write custom functions using Java and JavaScript
- use in SELECT, INSERT and UPDATE statements
- functions are only available within the keyspace where it is defined

**Creating UDFs Syntax**

Enabled by changing the following settings in the `cassandra.yaml` file

- Java: set `enable_user_defined_functions` to true
- JavaScript and other custom languages: set `enable_scripted_user_defined_functions` to true

##### UDAs

- DataStax Enterprise allows users to define aggregate functions
- functions are applied to data stored in a table as part of a query result
- the aggregate function must be created prior to its use in a SELECT statement
- query must only include trhe aggregate function itself - no additional columns

```sql
CREATE OR REPLACE
  FUNCTION avgState (state tuple<int,float>, val float)
  CALLED ON NULL INPUT
  RETURNS tuple<int, float>
  LANGUAGE java
  AS 'if (val != null) {
    state.setInt(0, state.getInt(0)+1);
    state.setFloat(1, state.getFloat(1)+val.floatValue());
  }
  return state;';

CREATE OR REPLACE
  FUNCTION avgFinal (sate tuple <int, float>)
  CALLED ON NULL INPUT
  RETURNS float
  LANGUAGE java
  AS 'float r = 0;
  if (state.getInt(0) == 0) return nul;
    r = state.getFloat(1);
    r/= state.getInt(0);
  return Float.valueOf(r);';

  CREATE AGGREGATE
    IF NOT EXISTS average (float);
    SFUNC avgState
    STYPE tuple<int,float>
    FINALFUNC avgFinal
    INITCOND (0,0);
  ```

##### Querying with a UDF and a UDA

- the state function is called once for each row
- the value returned by the state function becomes the new state
- after all rows are processed, the optional final function is executed with the last state value as its argument
- aggregation is performed by the coordinator

```sql
SELECT average(avg_rating) FROM videos WHERE release_year = 2002 ALLOW FILTERING;
SELECT average(avg_rating) FROM videos WHERE release_year = 2002 ALLOW FILTERING;
SELECT average(avg_rating) FROM videos WHERE release_year = 2002 ALLOW FILTERING;
SELECT average(avg_rating) FROM videos WHERE genres CONTAINS 'Romance' ALLOW FILTERING;
```


