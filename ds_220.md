- [DS220: Data Modelling with Apache Cassandra](#ds220-data-modelling-with-apache-cassandra)
  - [Data Modelling Overview](#data-modelling-overview)
  - [Relational vs. Apache Cassandra](#relational-vs-apache-cassandra)
    - [Relational Data Modelling Methodology](#relational-data-modelling-methodology)
    - [Cassandra Data Modelling Methodology](#cassandra-data-modelling-methodology)
    - [Transactions and ACID Compliance](#transactions-and-acid-compliance)
    - [Apache Cassandra and CAP Theorem](#apache-cassandra-and-cap-theorem)
    - [Apache Cassandra and Denormalization](#apache-cassandra-and-denormalization)
      - [Relational Joins](#relational-joins)
      - [Referential Integrity - Relational](#referential-integrity---relational)
  - [Working with KillrVideo](#working-with-killrvideo)
    - [Problems KillrVideo Faces](#problems-killrvideo-faces)
    - [Solutions attempted - Relational](#solutions-attempted---relational)
  - [Apache Cassandra Terminology](#apache-cassandra-terminology)
    - [Basic terms and definitions](#basic-terms-and-definitions)
    - [Text Data Types](#text-data-types)
    - [Integer Data Types](#integer-data-types)
    - [Time, timestamp and unique identifiers](#time-timestamp-and-unique-identifiers)
    - [Specialty Types](#specialty-types)
  - [Partitioning and Storage Structure](#partitioning-and-storage-structure)
  - [Clustering Columns](#clustering-columns)
    - [WITH CLUSTERING ORDER BY](#with-clustering-order-by)
    - [Querying Clustering Columns](#querying-clustering-columns)
  - [Denormalization](#denormalization)
  - [Collection Columns](#collection-columns)
    - [SET Collection Type](#set-collection-type)
    - [LIST Collection Type](#list-collection-type)
    - [MAP Collection Type](#map-collection-type)
    - [FROZEN](#frozen)
  - [UDT - User Defined Type](#udt---user-defined-type)
  - [Counters](#counters)
    - [Counter Considerations](#counter-considerations)
  - [User Defined Functions (UDFs) and User Defined Aggregates (UDAs)](#user-defined-functions-udfs-and-user-defined-aggregates-udas)
    - [UDFs](#udfs)
    - [UDAs](#udas)
    - [Querying with a UDF and a UDA](#querying-with-a-udf-and-a-uda)
  - [Conceptual Data Modeling](#conceptual-data-modeling)
    - [Purpose of Conceptual Modeling](#purpose-of-conceptual-modeling)
    - [Attribute Types](#attribute-types)
    - [Key Attributes](#key-attributes)
    - [Composite Attributes](#composite-attributes)
    - [Multi-Valued Attributes](#multi-valued-attributes)
    - [Entity-Relationship (ER) Model](#entity-relationship-er-model)
    - [Cardinality](#cardinality)
    - [Relationship Keys](#relationship-keys)
    - [Weak Entity Types](#weak-entity-types)
  - [Aplpication Workflow and Access Patterns](#aplpication-workflow-and-access-patterns)
  - [Mapping Conceptual to Logical Model](#mapping-conceptual-to-logical-model)
    - [Query-Driven Data Modeling](#query-driven-data-modeling)
    - [Chebotko Diagrams](#chebotko-diagrams)
    - [Chebotko Diagram Notation](#chebotko-diagram-notation)
    - [Data Modeling Principles](#data-modeling-principles)
    - [Single Partition Per Query - Ideal](#single-partition-per-query---ideal)
    - [Table Scan/Multi-Table Scan - Anti-Pattern](#table-scanmulti-table-scan---anti-pattern)
  - [Logical Data Modeling](#logical-data-modeling)
    - [Nest Data](#nest-data)
    - [Duplicate Data](#duplicate-data)
    - [Mapping rules of Data Modeling](#mapping-rules-of-data-modeling)
    - [Applying Mapping Rules](#applying-mapping-rules)
  - [Physical Data Modeling](#physical-data-modeling)
    - [CQL COPY Command](#cql-copy-command)
    - [SSTable Loader](#sstable-loader)
    - [DSE Bulk Loader](#dse-bulk-loader)
  - [Analysis and Validation](#analysis-and-validation)
    - [Reasons to change data model](#reasons-to-change-data-model)


### DS220: Data Modelling with Apache Cassandra

#### Data Modelling Overview

- Analyze requirements of the domain
- Identify entities and relationships - **Conceptual Data Model**
- Identify queries - **Workflow and Access Patterns**
- Specify the schema - **Logical Data Model**
- Get something working with CQL - **Physical Data Model**
- Optimize and tune

![Data Modelling Process](img/data_modelling_process.png)

*Data Modelling is a science:*

- Apply tested methodologies
- Make improvements
- Reproducible

*Data Modelling is also an art:*

- Think outside of the box
- Non-standard solution - requires creativity
- Be careful - different data models have different costs

> Main principle: design tables that support the queries.

#### Relational vs. Apache Cassandra

![Relational vs. Cassandra](img/relational_vs_cassandra.png)

##### Relational Data Modelling Methodology

(one of many)

![Relational Data Modelling Methodology](img/relational_methodology.png)

##### Cassandra Data Modelling Methodology

![Cassandra Methodology](img/cassandra_methodology.png)

> We consider Application Workflow earlier in the process and incorporating that analysis into the Logical Data Modelling Phase rather than waiting until we're optimizing a Physical Relational Model.

![Relational vs Cassandra](img/relational_vs_cassandra_1.png)

##### Transactions and ACID Compliance

*Relational DB are ACID compliant*

![ACID](img/acid.png)

**Cassandra doesn't support ACID semantics.**

- ACID causes a significant performance penalty
- Not required for many use cases
- However, a single Cassandra write operation demonstrates ACID properties
  - INSERTs, UPDATEs and DELETEs are atomic, isolated and durable
  - Tunable consistency for data replicated to nodes, but does not handle application integrity constraints

##### Apache Cassandra and CAP Theorem

![CAP Theorem](img/cap_theorem_2.png)

- by default, Cassandra is an AP database
- However, this is tunable with CL
- By tuning CL, you can make more CP than AP
- However! Cassandra isn't designed to be CA because you can't sacrifice partition tolerance

This is often referred as **tunable consistency**

##### Apache Cassandra and Denormalization

###### Relational Joins

> Joining users to comments table

![Relational Joins](img/relational_joins.png)

A join performs well when all of the relevant data is available on a single node. The main problem with joins in the distributed system is that the referenced data would most often exist on another node, which can have an unpredictable impact on the latency as the database scale increases.

![Denormalization](img/denormalization.png)

###### Referential Integrity - Relational

Joins rely on referential integrity constraints to combine data

- a value in one table requires the same value to exist in another table
- if there is a user in table `users_by_email` then the user must also exist in table `users`

![Referential Integrity](img/referential_integrity.png)

**Referential Integrity is not guaranteed by Cassandra, instead, we have to enforce it on the application level.**

- Due to performance reasons - would require a read before a write
- Not an issue that has to be fixed on the Apache Cassandra side
- Referential integrity can be enforced in an application design - more work for developers

OR

- Run DSE Analytics with Apache Spark to validate that duplicate data is consistent

#### Working with KillrVideo

![KillrVideo](img/killrvideo.png)

##### Problems KillrVideo Faces

- **Scalability** - Must be able to support constant addition of new users and videos
- **Reliability** - Must always be available
- **Ease of use** - Must be easy to manage and maintain

##### Solutions attempted - Relational

- single points of failure (when the DB crashes)
- scaling complexity
- reliability issues
- difficult to serve users worldwide (lag)

#### Apache Cassandra Terminology

##### Basic terms and definitions

**Data Model**
- an abstract model for organizing elements of data
- based on the queries you want to perform

**Keyspace**
- similar to relational schema - outermost grouping of data
- all tables live inside a keyspace
- keyspace is the container for replication

**Table**
- grouped into keyspaces
- contain columns

**Partition**
- rows of data that are stored on a particular node in your based on a partitioning strategy

More specific to the tables themselves

**Row**
- one or more CQL rows stored together on a partition

**Column**
- similar to a column in a relational database
- **primary key**: used to access the data in a table and guarantees uniqueness

**Partition key**
- defines the node on which the data is stored

**Clustering Column**
- defines the roder of rows **within** a partition

##### Text Data Types

- **Ascii**: US-ASCII characters
- **Text**: UTF-8 encoded string
- **Varchar**: UTF-8 encoded string

##### Integer Data Types

- **Tinyint**: 8-bit signed integer
- **Smallint**: 16-bit signed integer
- **Int**: 32-bit signed integer
- **Bigint**: 64-bit signed integer
- **Varint**: Arbitrary-precision integer - F-8 encoded string
- **Decimal**: Variable-precision decimal, supports integers and floats
- **Float**: 32-bit IEEE-754 floating point
- **Double**: 64-bit IEEE-754 floating point

##### Time, timestamp and unique identifiers

- **Date**: 32-bit unsigned integer - number of days since epoch (Jan 1, 1970)
- **Duration**: Signed 64-bit integer - amount of time in nanoseconds
- **Time**: Encoded 64-bit signed - number of nanoseconds since midnight
- **Timestamp**: 64-bit signed inteer - date and time since epoch in milliseconds
- **UUID**: 128-bit universally unique identifier - generate with the UUID function
- **TimeUUID**: unique identifier that includes a "conflict-free" timesdtamp - generate with the NOW function

##### Specialty Types

- **Blob**: Arbitrary bytes (no validation), expressed as hexadecimal
- **Boolean**: Stored internally as true or false
- **Counter**: 64-bit signed integer - only one counter column is allowed per table
- **Inet**: IP address string in IPv4 or IPv6 format

#### Partitioning and Storage Structure

![Storage Structure](img/storage_structure.png)

CQL's PARTITION KEY clause determines partitioning criteria in the primary key

**WHERE on non-primary key columns**

- Cassandra distributes partitions across nodes
- WHERE on any field other than partition key would require a scan of all partitions on all nodes
- Inefficient access pattern

![Nodes](img/nodes.png)

**WHERE on partition key values**
- We can WHERE on a partition key value as well as clustering columns
- Cassandra uses a hashing algorithm to quicly determine which node(s) contain the desired partition

![Nodes 2](img/nodes_2.png)

**Primary Key**

Simple Primary Key

- contains only the partition key
- determines which node stores the data
-
![Simple primary key](img/simple_primary_key.png)

**Composite Partition Keys**

Multi-value primary key

![Composite Partition Key](img/composite_partition_key.png)

**Primary Key vs. Partition Key**

- **Partition key**: the part of the primary key that determines what node the partition is stored on; where in the cluster is my data
- **Primary key**: includes partition key and any/all clustering columns; uniqueness
- Can they be the same? Yes! But not usually.

#### Clustering Columns

- come after partition key within PRIMARY KEY clause
- data displays the same as before

![Clustering Columns](img/clustering_columns.png)

Clustering sorts CQL rows in partitions

![Clustering Columns 2](img/clustering_columns_2.png)

![With vs. without clustering column](img/clustering_columns_3.png)

Clustering column values stored sorted

![Sorted Clustering Columns](img/sorted_clustering_columns.png)

##### WITH CLUSTERING ORDER BY

```sql
CREATE TABLE videos (
  id int,
  name text,
  runtime int,
  year int,
  PRIMARY KEY ((year), name)
) WITH CLUSTERING ORDER BY (name DESC);
```

##### Querying Clustering Columns

> You can query on clustering coumns because lookup is fast

```sql
SELECT * FROM videos WHERE year = 2014 AND name = 'Mockingjay';
```

![Query 1](img/query_1.png)

**Range**

```sql
SELECT * FROM videos WHERE year = 2014 AND name >= 'Interstellar';
```

![Query 2](img/query_2.png)

#### Denormalization

**Typical Relational Structure**

![Relational Structure](img/relational_structure.png)

```sql
SELECT comment FROM videos JOIN comments ON videos.id = comments.video_id WHERE title = 'Interstellar';
```

![Relational Example](img/relational_example.png)

![Results of the query](img/relational_query.png)

**Denormalizing for Quewry Performance**

![Denormalization](img/denormalization_1.png)

```sql
CREATE TABLE comments_by_video (
  video_title text,
  comment_id timeuuid,
  user_id text,
  video_id timeuuid,
  comment text,
  PRIMARY KEY ((video_title), comment_id)
);

CREATE TABLE comments_by_user (
  user_login text,
  comment_id timeuuid,
  user_id text,
  video_id timeuuid,
  comment text,
  PRIMARY KEY ((user_login), comment_id)
);
```

#### Collection Columns

Group and store data together in a column

- collection columns are multi-valued columns
- designed to store a small amount of data
- retrieved in its entirety
- cannot nest a collection inside another collection - unless you use FROZEN

##### SET Collection Type

- typed collection of unique values
- stored unordered, but retrieved in sorted order

```sql
CREATE TABLE users (
  id text PRIMARY KEY,
  fname text,
  lname text,
  emails set<text>
);

INSERT into users (id, fname, lname, emails)
VALUES ('cass123', 'Cassandra', 'Dev', {'cass@dev.com', 'cassd@gmail.net'});
```

##### LIST Collection Type

- like SET - collection of values in same cell
- do not need to be unique and can be duplicated
- stored in a particular order

```sql
ALTER TABLE users ADD freq_dest list<text>;

UPDATE users SET freq_dest = ['Berlin', 'London', 'Paris'] WHERE id = 'cass123';
```

##### MAP Collection Type

- typed collection of key-value pairs - name and pair of typed values
- ordered by unique keys

```sql
ALTER TABLE users ADD todo map<timestamp , text>;

UPDATE users SET todo = {'2018-1-1' : 'create database', '2018-1-2' : 'load data and test', '2018-2-1' : 'move to production'} WHERE id = 'cass123';
```

##### FROZEN

- if you want to nest datatypes, you have to use FROZEN
- using FROZEN in a collection will serialize multiple components into a single value
- values in a FROZEN collection are treated like blobs
- non-frozen types allow updates to individual fields

#### UDT - User Defined Type

Attach multiple data fields to a column

- UDTs group related fields of information
- UDTs can attach multiple data fields, each named and typed, to a single column
- can be any datatype including collections and other UDTs
- allows embedding more complex data within a single column

> Creating the Types

```sql
CREATE TYPE address (
  street text,
  city text,
  zip_code int,
  phones set<text>
);

CREATE TYPE full_name (
  first_name text,
  last_name text
);
```

> Using the newly created types in a table definition

```sql
CREATE TABLE users (
  id uuid,
  name frozen <full_name>,
  direct_reports set<frozen <full_name>>,
  addresses map<text, frozen <address>>,
  PRIMARY KEY ((id))
);
```

#### Counters

- column used to store a 64-bit signed integer
- changed incrementally - incremented or decremented
- values are changed using UPDATE
- need specially dedicated tables - can only have primary key and counter columns
  - can have more than one counter column

```sql
CREATE TABLE moo_counts (
  cow_name text,
  moo_count counter,
  PRIMARY KEY ((cow_name))
);

UPDATE moo_counts SET moo_count = moo_count + 8 WHERE cow_name = 'Betsy';
```

##### Counter Considerations

> Some things to be aware of

- distributed system can cause consistency issues with counters in some cases
- cannot INSERT or assign values - default value is "0"
- must be only non-primary key column(s)
- not idempotent
- must use UPDATE command - DataStax Enterprise rejects USING TIMESTAMP or USING TTL to update counter columns
- counter columns cannot be indexed or deleted

#### User Defined Functions (UDFs) and User Defined Aggregates (UDAs)

##### UDFs

- write custom functions using Java and JavaScript
- use in SELECT, INSERT and UPDATE statements
- functions are only available within the keyspace where it is defined

**Creating UDFs Syntax**

Enabled by changing the following settings in the `cassandra.yaml` file

- Java: set `enable_user_defined_functions` to true
- JavaScript and other custom languages: set `enable_scripted_user_defined_functions` to true

##### UDAs

- DataStax Enterprise allows users to define aggregate functions
- functions are applied to data stored in a table as part of a query result
- the aggregate function must be created prior to its use in a SELECT statement
- query must only include trhe aggregate function itself - no additional columns

```sql
CREATE OR REPLACE
  FUNCTION avgState (state tuple<int,float>, val float)
  CALLED ON NULL INPUT
  RETURNS tuple<int, float>
  LANGUAGE java
  AS 'if (val != null) {
    state.setInt(0, state.getInt(0)+1);
    state.setFloat(1, state.getFloat(1)+val.floatValue());
  }
  return state;';

CREATE OR REPLACE
  FUNCTION avgFinal (sate tuple <int, float>)
  CALLED ON NULL INPUT
  RETURNS float
  LANGUAGE java
  AS 'float r = 0;
  if (state.getInt(0) == 0) return nul;
    r = state.getFloat(1);
    r/= state.getInt(0);
  return Float.valueOf(r);';

  CREATE AGGREGATE
    IF NOT EXISTS average (float);
    SFUNC avgState
    STYPE tuple<int,float>
    FINALFUNC avgFinal
    INITCOND (0,0);
  ```

##### Querying with a UDF and a UDA

- the state function is called once for each row
- the value returned by the state function becomes the new state
- after all rows are processed, the optional final function is executed with the last state value as its argument
- aggregation is performed by the coordinator

```sql
SELECT average(avg_rating) FROM videos WHERE release_year = 2002 ALLOW FILTERING;
SELECT average(avg_rating) FROM videos WHERE release_year = 2002 ALLOW FILTERING;
SELECT average(avg_rating) FROM videos WHERE release_year = 2002 ALLOW FILTERING;
SELECT average(avg_rating) FROM videos WHERE genres CONTAINS 'Romance' ALLOW FILTERING;
```

#### Conceptual Data Modeling

> Modeling your domain

![Data Modeling Methodology](img/data_modeling_methodology.png)

- abstract view of your domain
- technology independent
- not specific to anyd atabase system

![Conceptual Data Model](img/conceptual_data_model.png)

##### Purpose of Conceptual Modeling

- understand your datas
- essential objects
- constraints

##### Attribute Types

- fields to store data about an entty or relationship

##### Key Attributes

- identifies an object

![Key Attributes](img/key_attributes.png)

##### Composite Attributes

- groups related attributes together

![Composite Attributes](img/composite_attributes.png)

##### Multi-Valued Attributes

- attribute stores multiple values per entity

![Multi Valued Attributes](img/multivalued_attributes.png)

##### Entity-Relationship (ER) Model

- Entity Types - Relationship Types - Attribute Types

![Entity Types](img/entity_types.png)

![Relationship Types](img/relationship_types.png)

##### Cardinality

- relationships between entities
- number of times an entity can/must participate in the relationship
- other possibilities
  - 1-n
  - 1-1

![Cardinality](img/cardinality.png)

##### Relationship Keys

![Relationship Keys](img/relationship_keys.png)

##### Weak Entity Types

- cannot exist without an identifying relationship to a strong entity type

![Weak Entity Type](img/weak_entity_type.png)

#### Aplpication Workflow and Access Patterns

![Application Workflow](img/application_workflow.png)

- each application has a workflow - tasks/causal dependencies form a graph
- access patterns help determine how data is acessed - know what queries you will run first
- example task: have a user login to a site

Task: show videos that were uploaded by a particular user

![Task example](img/task_example.png)

#### Mapping Conceptual to Logical Model

##### Query-Driven Data Modeling

![Query Driven Data Modeling](img/query_driven_data_modeling.png)

##### Chebotko Diagrams

- graphical representation of Cassandra database schema design
- documents the logical and physical data model

![Chebotko Diagrams](img/chebotko_diagrams.png)

##### Chebotko Diagram Notation

> Table representation

- logical-level shows column names and properties
- physical-level also shows the column data type
-
![Chebotko Diagram Notation](img/chebotko_diagram-notation.png)

> Logical UDT Diagram

- represents user defined types and tuples

![Logical UDT Diagram](img/logical_udt_diagram.png)

> Physical UDT Diagram

- represents user defined types and tuples

![Physical UDT Diagram](image.png)

Example Chebotko Diagram

![Example Chebotko Diagram](img/example_chebotko_diagram.png)

##### Data Modeling Principles

- **know your data**
  - data captured by conceptual data model
  - define what is stored in database
  - preserve properties so that data is organized properly
  - ![Know Your Data](img/know_your-data.png)
- **know your queries**
  - queries captured by application workflow model
  - table schema design changes if queries change
  - ![Know Your Queries](img/know_your_queries.png)
- **nest data**
- **duplicate data**

##### Single Partition Per Query - Ideal

> Schema design organizes data to efficiently run queries

- most efficient access pattern
- query accesses only one partition to retrieve results
- partition can be single-row or multi-row

##### Table Scan/Multi-Table Scan - Anti-Pattern

- least efficient type of query but may be needed in some cases
- query needs to access all partitions in a table(s) to retrieve results

#### Logical Data Modeling

##### Nest Data

> Data nesting is the main data modeling technique

- nesting organizes multiple entities into a single partition
- supports partition per query data access
- three data nesting mechanisms:
  - **clustering columns - multi-row partitions**
    > primary data nesting mechanism
    - partition key identifies an entity that other entitites will nest into
    - values in a clustering column identify the nested entities
    - multiple clustering columns implement multi-level nesting
    ![Nest data - Clustering Columns](img/nest_data_clustering_columns.png)

  - **collection columns**
  - **user-defined type columns**
    > User-defined type - secondary data nesting mechanism
    - represents one-to-one relationship, but can use in conjunction with collections
    - easier than working with multiple collection columns
    ![Nest Data - UDT](img/nest_data_udt.png)

##### Duplicate Data

> Better to duplicate than to join

- partition per query and data nestimg may result in data duplication
- query results are pre-computed and materialized
- data can be duplicated across tables, partitions and/or rows

![Duplicate data](img/duplicate_data.png)

> Data duplication can scale, joins can not

![Duplication Scale](img/duplication_scale.png)

##### Mapping rules of Data Modeling

1. Entities and relationships
2. Equality search attributes
3. Inequality search attributes
4. Ordering attributes
5. Key attributes

##### Applying Mapping Rules

- create a schema from the conceptual data model and for each query
- apply the mapping rules in order

![Mapping Rules](img/mapping_rules.png)

#### Physical Data Modeling

![Physical Data Model](img/physical_data_model.png)

> Adding data types and creating tables

![Physical Model](img/physical_model.png)

> Writing the CQL statements

![CQL](img/cql.png)

> Loading Data Methods

- COPY command
- SSTable loader
- DSE Bulk Loader

##### CQL COPY Command

- COPY TO exports data from a table to a CSV file
- COPY FROM imports data to a table from a CSV file
- the process verifies the PRIMARY KEY and updates existing records
- if HEADER = false is specified the fileds are imported in deterministic order
- when column names are specified, fields are imported in that order - missing and empty fields set to null
- source cannot have more fields than the target table - can have fewer fields

```sql
COPY table1 (column1, column2, column3) FROM 'table1data.csv' WITH HEADER=true;
```

##### SSTable Loader

- bulk load external data into a cluster
- load pre-existing SSTables into
  - an existing cluster or new cluster
  - a cluster with the same number of nodes or a different number of nodes
  - a cluster with a different replication strategy or partitioner

`sstableloader -d  110.82.155.1 /var/lib/cassandra/data/killrvideo/users/`

##### DSE Bulk Loader

- moves Cassandra data to/from files in the file system
- uses both CSV or JSON formats
- command-line interface
- used for loading large amounts of data fast

`dsbulk load -url file1.csv -k ks1 -t table1`

#### Analysis and Validation

![Optimization tuning](img/optimization_tuning.png)

##### Reasons to change data model

- requirements change in the domain
- the data model is no longer efficient
- data is becoming imbalanced
- unforseen load on particular nodes leading to hotspotting

**Changing data model or handling new requirements**

Important considerations:

- natural or surrogate keys?
- are write conflicts (overwrites) possible?
- what data types to use?
- how large are partitions?
- how much data duplication is required?
- are client-side joins required and at what cost?
- are data consistency anomalies possible?
- how to enable transactions and data aggregation?


